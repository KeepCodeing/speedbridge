# 算法竞赛入门

> 作为算法&蓝桥杯的入门讲义，会解答竞赛相关概念与基础算法题，以及讲解基础算法。

## 算法基础概念

### 学习算法需要什么

个人观点：大部分算法都是可以通过**分支选择循环函数数组输入输出**实现的。具体而言，只要我们掌握了一门语言的**基础语法**，那么写出一个算法是没有任何问题的。

也就是说学习了语法基础的各位完全可以着手学习算法了。

### 时空复杂度

时空复杂度指**时间复杂度**和**空间复杂度**。它们是衡量我们**算法质量**的重要标准，同时也是算法竞赛中重要考核标准之一。

**时间复杂度**：简单而言指的是我们程序的**运行时间**。在算法竞赛中它更多指的是算法的运行时间，也就是**算法复杂度**。一般而言，蓝桥杯中大部分编程题都要求我们在`1s`的时间内完成，少部分情况是`500ms`，如果某个**测试点运行超时，则不得分**。

**空间复杂度**：指我们程序运行时占用的**内存空间**。假如一个`int`类型的数据占用`1MB`空间，那么`int[256]`就会占用`256MB`空间，如果某个**测试点内存超限，则不得分**。

**算法复杂度**：算法复杂度采用**大O法**表示，有许多算法的复杂度都是被前人证明了的，简单的复杂度计算我们通过程序说明。这里特别强调，我们判断复杂度的根据是**数据范围**，例如某题目指出数据范围是`0 <= n <= 1e8`，那么我们将这个`n`带入下面的循环，会得到`O(n)`复杂度的算法可能会在极限数据超时的结论，这是因为C++一秒能执行的循环次数差不多就是`1e8`左右。

```c++
/* 这里有个运行了n次的循环，那么它的复杂就是O(n) */
for (int i = 0; i <= n; i++);

/* 这里有个二层嵌套的n次循环，那么它的复杂度就是O(n) */
for (int i = 0; i <= n; i++) {
    for (int j = 0; j <= n; j++);
}

/* 如果存在多个循环，但不是嵌套关系，那么它们的复杂度也是O(n) */
for (int i = 0; i <= n; i++);
for (int i = 0; i <= n; i++);
for (int i = 0; i <= n; i++);

/* 类似赋值等操作其复杂度可以认为是O(1)的，部分算法的时间复杂度为常数，也可以近似认为是O(1)的 */
int i = 1;
printf("%d", i);

/* 上述是简单的算法复杂度计算，也就是通过循环判断，事实上大部分算法的时间复杂度都是已知的，下面列举一些常用算法的复杂度 */
/*
普通并查集: O(n)
路径压缩并查集: O(logN) 注意，除非特殊说明，否则在大O表示法下的log都是以2为底的
按秩合并并查集: O(logN)
路径压缩 + 按秩合并并查集: O(a函数) 近似为 O(1)

这里枚举了四种并查集算法的复杂度是想告诉大家算法的复杂度是可以通过优化降低的

快速幂: O(logN)
埃氏筛: O(loglogN)
试除法: O(n^1/2)
卡特兰数: O(n)
dfs/bfs: 指数级 这两个算法的复杂度一般都相当高，而且没有固定的计算方法
其它算法...
*/
```

### 推荐OJ

OJ，意为online judge，也就是在线评测平台，是我们刷题必不可少的工具。

1. 洛谷，竞赛题目全，有题解。
2. 力扣，题目针对面试，但不影响，题目解析相当全面，入门学习某个算法事半功倍。
3. Vjudge，各类OJ的聚合，可以在上面找到很多算法书练习题题单。
4. AcWing，课程+练习一体的OJ，推荐学习上面的课程。

### 推荐书籍

自学为主，这里只推荐了书籍资源，大家也可以在B站或者别的平台找视频教程看。

1. 《啊哈！算法》，入门书，知识点讲解简单易懂，缺点是内容太少。
2. 《算法图解》，入门书，图文并茂，简单易懂，缺点是程序用Python2编写。
3. 《大话数据结构》，入门书，用例子解释数据结构，缺点是有部分内容描述错误。
4. 《算法笔记》，进阶书，常用算法和数据结构基本都提到了，介绍了**STL**，缺点是部分内容不详细。
5. 《挑战程序设计竞赛》，进阶书，内容面向ACM，例子丰富，缺点是部分内容蓝桥杯用不到。
6. 《算法（第四版）》，进阶书，内容面向常用算法（没有DP），程序用Java编写。
7. 《算法竞赛入门经典》，进阶书，例子丰富，缺点是难度不止“入门”，需要一定基础。
8. 《算法竞赛进阶指南》，提高书，内容面向NOI，内容全面，缺点是部分内容蓝桥杯用不到。
9. 《数据结构与算法分析：C语言描述》，扩展书。
10. 《算法导论》，扩展书。

## 蓝桥杯赛制讲解

蓝桥杯软件类（Python/C&C++/JAVA B组）的省赛国赛赛制是相同的，故不分开讲解。

### 基本信息

**比赛时间4小时**。比赛形式是上机，一般而言比赛环境会提前配置好，无需手动配置。全程无网络连接，答案通过指定地址提交到服务器。一共十题，包括**五道填空题，五道编程题**，每个题目都有自己的分值。

### 题目类型

#### 填空题

填空题一共五道，**只需要提交答案**即可。不限制解题方式（任意编程语言，任意工具都可以），答案正确才能拿分。

例如：`给定数列，1,3,5...13，求该数列之和。`使用计算器、编写程序都是可以解出来的。

技巧：如果题目考察到了**时间、日期**等需要手动模拟的内容，可以使用**`Excel`**，直接计算。

#### 编程题

编程题一共五道，必须提交**完整的程序代码，且测试点答案正确**才能得分，即使只通过了部分测试点，也可以拿到这些测试点的分数，测试点全部通过则满分。

编程题会限定**算法运行时间、测试数据范围**，也就是前面的时空复杂度，同时会提供若干测试数据。

例如：`给定正整数n，求1~n范围内存在多少个素数，并将这些素数打印出来。 运行时间: 1s 对于30%的测试数据有0 <= n <= 100，对于的60%测试数据有0 <= n <= 1000，对于100%的测试数据有0 <= n < 10000000`。

技巧：如果数据范围很小（如上例60%的数据），但又没法写出正解，可以**使用暴力算法拿到部分分**。

### 评测赛制

蓝桥杯采用的是**OI赛制**，每道题提交之后都**没有任何反馈**，每道题都有**多个测试点**，根据每道题**通过的测试点的数量**获得相应的**分数**。每道题**不限制提交次数**，如果提交错误没有任何惩罚，仅以最后一次提交为准。比赛过程中看不到实时排名，赛后按照总得分来排名。

一句话总结：可无限次提交，答案以最后一次为准，没有错误惩罚，按点计分，比赛中无法获知分数情况，排名根据总分。

### 比赛环境

C/C++组可以使用`Dev C++`或者`Code Block`，推荐使用前者，操作简单。

Java组可以使用`eclipse`或者`IDEA`。

Python组可以使用`IDEL`或者`PyCharm`。

## 模拟算法

今天的课程主要讲解的是“**模拟**”算法，作为各种算法的基石，它并没有明确的定义，其难度上下限都非常高。模拟题考察的是我们的**程序设计能力**，语言基础好，写起来就相对容易。

### 真题

#### 单词分析

[单词分析 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/504/learning/)

思路：本题考查C语言基础，我们知道字符本质是`ASCII`码存储的，例如字符`A`对应的`ASCII`码是**65**，依次类推，我们可以得出字符`Z`对应的`ASCII`码为**90**。我们使用一个数组，利用下标统计字符出现次数即可。

```c++
#include <iostream>
using namespace std;
const int N = 26;
int cnt[N];
int main()
{
  char c;
  int ans = -1;
  char ch = ' ';
  // char str[1010];
  // scanf("%s", &str);
  while (cin >> c) cnt[c - 'a']++;
  for (int i = 0; i < N; i++) {
    if (ans < cnt[i]) {
      ans = cnt[i];
      ch = i + 'a';
    }
  }
  cout << ch << endl << ans << endl;
  return 0;
}
```

#### 成绩统计

[成绩统计 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/502/learning/)

思路：本题考查C语言基础，相信这种题大家C语言课就做过了。首先我们考虑需不需要将学生成绩存储下来，很明显，不需要，我们在输入的过程中就已经拿到成绩了；接下来我们考虑如何实现**四舍五入**，这里有一个小技巧`%f`之类的输出格式修饰符自带四舍五入功能，舍去的小数点位数会被自动四舍五入；最后`%`的输出需要使用`%%`转义，语法基础。

```c++
#include <iostream>
#include <stdio.h>
using namespace std;
int main()
{
  // 请在此输入您的代码
  int n, s, t;
  // pass great 及格，优秀
  int p = 0, g = 0;
  cin >> n;
  t = n;
  while (n--) {
    cin >> s;
    if (60 <= s && s < 85) p++;
    else if (s >= 85) g++, p++;
  }
  // 计算及格率，优秀率
  printf("%.0f%%\n%.0f%%", (p / (t + .0)) * 100, (g / (t + .0)) * 100);
  return 0;
}
```

#### 回文日期

[回文日期 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/498/learning/)

思路：本题考查日期模拟，数字字符串转换。我们将题目的要求分成两部分：

1. 如何推算时间，也就是保证枚举出来的时间是合法的。
2. 如何判断当前日期是否符合答案格式。

针对第一个问题，我们可以将日期划分成`YYYY-MM-DD`的格式，也就是年月日分开，再采用**“进位”**的方式枚举时间，这里注意细节，需要判断闰年。”进位“指的是下面的这种情况`2022-1-31` -> `2022-2-1`。

针对第二个问题，我们可以将**数字转换为字符串**，这是因为作为日期作为数字是没办法补**前导零**的，也就是数字没法表示`01`这种情况。将数字转换为字符串，实际上就是让数字变成它的`ASCII`码表示，也就是`0 -> '0'`，其原理和**单词分析**这一题是一样的。

```c++
#include <iostream>
#include <cstdio>
#include <sstream>
using namespace std;

int dtable[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

// 日期转字符串
string date2str(int y, int m, int d) {
	string sy, sm, sd;
	stringstream ss;
	ss << y;
	ss >> sy;
	ss.clear();

	ss << m;
	ss >> sm;
	ss.clear();

	ss << d;
	ss >> sd;
	ss.clear();

	if (sm.size() <= 1) sm = "0" + sm;
	if (sd.size() <= 1) sd = "0" + sd;

	return sy + sm + sd;
}

int main() {
	// 请在此输入您的代码
	int y, m, d;
	bool f1 = false, f2 = false;

	scanf("%4d%2d%2d", &y, &m, &d);


	while (!f1 || !f2) {
		// 闰年：四年一闰，百年不闰，四百年又一闰
		// 如果是闰年，则2月会多一天
		if ((y % 4 == 0 && y % 100 != 0) || (y % 400 == 0))
			dtable[2]++;
		// 枚举日期
		while (true) {
			// 当前日不满这月的天数，递增
			// 满了之后月递增
			if (d++ >= dtable[m]) m++, d = 1;
			// 满了12月后年递增，二月份天数重新计算，并且重置日月
			if (m > 12) {
				dtable[2] = 28;
				d = 0;
				m = 1;
				y++;
				break;
			}
			string dstr = date2str(y, m, d);
			int l = 0, r = dstr.size() - 1;
			if (!f1) {
				f1 = true;
				while (l < r)
					if (dstr[l++] != dstr[r--]) f1 = false;
				if (f1) cout << dstr << endl;
			}
			
			if (dstr[0] == dstr[2] && dstr[0] == dstr[5] && dstr[0] == dstr[7]
				&& dstr[1] == dstr[3] && dstr[1] == dstr[4] && dstr[1] == dstr[6]) {
					f2 = true;
					cout << dstr << endl;	
				}
			if (f1 && f2) break;
			// ABABBABA

//			cout << date2str(y, m, d) << endl;
//			cout << y << ' ' << m << ' ' << d << endl;
		}

//		break;


	}

	return 0;
}
```

#### 门牌制作

[门牌制作 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/592/learning/)

思路：将数字拆解，例如`1877`就需要1个1，1个8，2个7，那么统计2出现的次数即可。

```c++
#include <iostream>
using namespace std;
int main()
{
  // 请在此输入您的代码
  int cnt = 0;
  for (int i = 1; i <= 2020; i++) {
    int t = i;
    while (t) {
      if (t % 10 == 2) cnt++;
      t /= 10;
    }
  }
  cout << cnt << endl;
  return 0;
}
```

#### 串的处理

[串的处理 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/287/learning/)

思路：这个题的处理单位是单词，但单词在题目中的定义是**由 1 个或多个空格分隔**分隔的字符串，于是可以得到三个问题：

1. 如何将多个空格变为一个空格。
2. 如何将首字母大写。
3. 如何将数字与字母间通过下划线分隔。

问题一可以在输入时解决，`C++`的`cin`在读取字符串时会**自动省略空格**，也就是无论有多少个空格都不影响单词输入。同理，`scanf`也具备这个功能。如果我们采用一行输入的方式，会增加工作量。

问题二中的首字母定义是单词的第一个字母，那么我们将输入的字符串看成一个数组`str`，则`str[0]`就是首字母，将小写字符转为大写字符只需要减去它们`ASCII`的差值即可，也就是`'a' - 'A' = 32`，转为小写即`'a' - 32 = 'A'`，这里需要特别判断下，如果当前字母已经是**大写字母或非字母，则不需要转换**。

问题三需要我们遍历字符串，获取每一位的字母。按照字面意思理解，题目的要求似乎是让我们在*字母和数字间插入下划线*，这样做同样会让程序变得更加复杂。实际上我们不需要真正插入下划线，只需要在**前一位是字母，当前位是数字**以及**前一位是数字，当前一位是字母**的情况下**输出下划线**即可。将情况细分，我们还可以将当前只有一个数字和当前有多个数字的情况分开讨论，例如`a1a`是当前只有一个数字的情况，`h123g`，是当前存在多个数字的情况，对于前者，可以特殊判断；后者则按照规则处理，而中间的数字原样打印。

```c++
#include <iostream>
#include <cstdio>
using namespace std;

// 一位数字：前后都是字母，直接输出_数字_
// 多位数字：左边是字母，输出_数字，右边是字母，输出数字_，中间数字原样输出

// 判断当前字符是否是字母
bool isAlpha(char c) {
  return 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z';
}

int main()
{
  // 请在此输入您的代码
  string str;
  while (cin >> str) {
    // 针对小写字符首字母大写
    if ('a' <= str[0] && str[0] <= 'z') str[0] -= 32;
    int sLen = str.size();
    for (int i = 0; i < sLen; i++) {
      // 枚举数字位置的几种情况
      if (!isAlpha(str[i])) {
        // 如果是h1h这种类型的情况，输出h_1_h
        if (isAlpha(str[i - 1]) && isAlpha(str[i + 1])) cout << "_" << str[i] << "_";
        // 如果是h123这种情况，输出h_1
        else if (i >= 1 && isAlpha(str[i - 1])) cout << "_" << str[i];
        // 如果是123h这种情况，输入3_h
        else if (i < sLen - 1 && isAlpha(str[i + 1])) cout << str[i] << "_";
        // 中间字符原样输出
        else cout << str[i];
      } else cout << str[i]; // 字母原样输出
    }
    cout << ' ';
  }
  return 0;
}
```